//go:generate goyacc -l -o parser.go parser.y

package goyacc

import (
	"errors"
	"io"
	"text/scanner"
	"unicode"
)

type nodeType int

const (
	op nodeType = iota + 1
	label
)

const (
	orOp  = "OR"
	andOp = "AND"
)

// node represents a node in abstract syntax tree
type node struct {
	typ         nodeType
	val         string
	left, right *node
}

// ast is the abstract syntax tree for a label formula
type ast struct {
	root *node
}

func parse(name string, src io.Reader) (*ast, error) {
	l := newLexer(name, src)
	yyParse(l) // generated by goyacc

	return l.ast, l.err
}

// lexer implements yyLexer interface for the parser generated by goyacc
type lexer struct {
	s   scanner.Scanner
	err error
	ast *ast
}

func newLexer(name string, src io.Reader) *lexer {
	var s scanner.Scanner
	s.Init(src)
	s.Filename = name

	// Accept tokens with "-"
	s.IsIdentRune = func(ch rune, i int) bool {
		return unicode.IsLetter(ch) || unicode.IsDigit(ch) && i > 0 || ch == '-' && i > 0
	}

	return &lexer{
		s: s,
	}
}

func (l *lexer) Error(msg string) {
	l.err = errors.New(msg)
}

// yySymType is generated by goyacc
func (l *lexer) Lex(lval *yySymType) int {
	if token := l.s.Scan(); token == scanner.EOF {
		return -1
	}

	lexeme := l.s.TokenText()

	switch lexeme {
	case "(":
		return OPEN // generated by goyacc
	case ")":
		return CLOSE // generated by goyacc
	case ",":
		lval.op = andOp
		return OP // generated by goyacc
	case ";":
		lval.op = orOp
		return OP // generated by goyacc
	default:
		lval.label = lexeme
		return LABEL // generated by goyacc
	}
}
